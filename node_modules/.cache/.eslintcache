[{"/Users/kaandai/Desktop/react-freash-canvas/src/App.js":"1","/Users/kaandai/Desktop/react-freash-canvas/src/Sidebar.js":"2","/Users/kaandai/Desktop/react-freash-canvas/src/CanvasComponent.js":"3","/Users/kaandai/Desktop/react-freash-canvas/src/index.js":"4","/Users/kaandai/Desktop/react-freash-canvas/src/reportWebVitals.js":"5"},{"size":766,"mtime":1690724972282,"results":"6","hashOfConfig":"7"},{"size":2219,"mtime":1690725117559,"results":"8","hashOfConfig":"7"},{"size":9968,"mtime":1690722992108,"results":"9","hashOfConfig":"7"},{"size":535,"mtime":1690216923172,"results":"10","hashOfConfig":"7"},{"size":362,"mtime":1690216923173,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","suppressedMessages":"14","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"15"},"1t0wh42",{"filePath":"16","messages":"17","suppressedMessages":"18","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"19","messages":"20","suppressedMessages":"21","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"22","usedDeprecatedRules":"15"},{"filePath":"23","messages":"24","suppressedMessages":"25","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"26","messages":"27","suppressedMessages":"28","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/kaandai/Desktop/react-freash-canvas/src/App.js",[],[],[],"/Users/kaandai/Desktop/react-freash-canvas/src/Sidebar.js",[],[],"/Users/kaandai/Desktop/react-freash-canvas/src/CanvasComponent.js",["29","30","31","32"],[],"import React, { useEffect, useRef, useState, useCallback } from 'react';\nimport './App.css';\nconst CanvasComponent = () => {\n    \n    const canvasRef = useRef(null);\n    const [canvasItems, setCanvasItems] = useState([]);\n    //const [dragItem, setDragItem] = useState(null);\n    const [dragging, setDragging] = useState(false);\n    const [dragItemIndex, setDragItemIndex] = useState(null);\n\n\n\n    // Variables for panning\n    const [panX, setPanX] = useState(0);\n    const [panY, setPanY] = useState(0);\n\n    // Variables for zooming\n    const [zoom, setZoom] = useState(1);\n    const zoomFactor = 1.01;\n    const minZoom = 0.6; // minimum zoom level\n    const maxZoom = 3; // maximum zoom level\n\n    // Variables for mouse panning\n    const [isPanning, setIsPanning] = useState(false);\n    const [startPanX, setStartPanX] = useState(0);\n    const [startPanY, setStartPanY] = useState(0); \n\n    const drawGrid = useCallback((ctx, canvas) => {\n      ctx.beginPath();\n      ctx.strokeStyle = \"lightgray\";\n      ctx.lineWidth = 2;\n    \n      // calculate the number of lines to draw based on the zoom level\n      const numLines = Math.ceil(Math.max(canvas.width, canvas.height) / (5 * zoom));\n      \n      // draw vertical lines\n      for (let i = -numLines; i <= numLines; i++) {\n        const x = (panX % (15 * zoom)) + i * 15 * zoom;\n        ctx.moveTo(x, -canvas.height);\n        ctx.lineTo(x, canvas.height);\n      }\n      \n      // draw horizontal lines\n      for (let i = -numLines; i <= numLines; i++) {\n        const y = (panY % (20 * zoom)) + i * 15 * zoom;\n        ctx.moveTo(-canvas.width, y);\n        ctx.lineTo(canvas.width, y);\n      }\n    \n      ctx.stroke();\n  }, [panX, panY, zoom]);\n\n    // Draw function\n    const draw = useCallback((ctx, canvas) => {\n      // clear canvas\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n      // save context state\n      ctx.save();\n    \n      // translate and scale context\n      ctx.translate(panX, panY);\n      ctx.scale(zoom, zoom);\n    \n      // draw grid\n      drawGrid(ctx, canvas);\n    \n      // restore context state\n      ctx.restore();\n    \n      // request next animation frame\n      requestAnimationFrame(() => draw(ctx, canvas));\n    \n      // Adjust the font size according to the zoom level\n      ctx.font = `${16 * zoom}px Arial`;\n      ctx.fillStyle = \"black\";\n    \n      for (const item of canvasItems) {\n        const adjustedX = item.x * zoom + panX;\n        const adjustedY = item.y * zoom + panY;\n        ctx.fillText(item.text, adjustedX, adjustedY);\n      }\n    }, [panX, panY, zoom, canvasItems, drawGrid]);\n    \n\n    const onDrop = (event) => {\n      event.preventDefault();\n      const data = event.dataTransfer.getData(\"text/plain\");\n    \n      // Calculate the position where the item was dropped and add the item to the canvas items array\n      const rect = canvasRef.current.getBoundingClientRect();\n      const x = (event.clientX - rect.left - panX) / zoom;\n      const y = (event.clientY - rect.top - panY) / zoom;\n      setCanvasItems([...canvasItems, { text: data, x, y }]);\n    };\n    \n\n    const onDragOver = (event) => {\n        event.preventDefault();  // This is necessary to allow a drop.\n    };\n\n    const onMouseDown = useCallback((event) => {\n      const rect = canvasRef.current.getBoundingClientRect();\n      const mouseX = (event.clientX - rect.left - panX) / zoom;\n      const mouseY = (event.clientY - rect.top - panY) / zoom;\n\n      for (let i = canvasItems.length - 1; i >= 0; i--) {\n        const item = canvasItems[i];\n        // considering each character as 16px wide and 24px tall\n        if (\n          mouseX >= item.x && \n          mouseX <= item.x + (16 * item.text.length) &&\n          mouseY >= item.y - 24 && \n          mouseY <= item.y\n        ) {\n          setDragging(true);\n          setDragItemIndex(i);\n          break;\n        }\n      }\n    }, [canvasItems, panX, panY, zoom]);\n\n    const onMouseUp = useCallback(() => {\n      setDragging(false);\n      setDragItemIndex(null);\n    }, []);\n\n    const onMouseMove = useCallback((event) => {\n      if (isPanning) {\n          // calculate new pan values\n          let newPanX = event.clientX - startPanX;\n          let newPanY = event.clientY - startPanY;\n    \n          // define maximum and minimum allowed pan values\n          const maxPanX = 900;\n          const maxPanY = 500;\n          const minPanX = 800;\n          const minPanY = 300;\n    \n          // check if new pan values exceed maximum or minimum allowed values\n          if (newPanX > maxPanX) {\n              newPanX = maxPanX;\n          } else if (newPanX < minPanX) {\n              newPanX = minPanX;\n          }\n          if (newPanY > maxPanY) {\n              newPanY = maxPanY;\n          } else if (newPanY < minPanY) {\n              newPanY = minPanY;\n          }\n    \n          // update pan values\n          setPanX(newPanX);\n          setPanY(newPanY);\n      } else if (dragging && dragItemIndex !== null) {\n          // update position of dragged item\n          const rect = canvasRef.current.getBoundingClientRect();\n          const x = (event.clientX - rect.left - panX) / zoom;\n          const y = (event.clientY - rect.top - panY) / zoom;\n          setCanvasItems((prevItems) => {\n              const newItems = [...prevItems];\n              newItems[dragItemIndex] = { ...newItems[dragItemIndex], x, y };\n              return newItems;\n          });\n      }\n    }, [dragging, dragItemIndex, isPanning, panX, panY, startPanX, startPanY, zoom]);\n    \n  \n    \n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n    let animationFrameId;\n\n    const render = () => {\n        draw(ctx, canvas);\n        animationFrameId = window.requestAnimationFrame(render);\n    };\n    render();\n\n    // Add event listeners for panning and zooming\n    const handleMouseDown = (event) => {\n        // check if user clicked on an item\n        const rect = canvasRef.current.getBoundingClientRect();\n        const mouseX = (event.clientX - rect.left - panX) / zoom;\n        const mouseY = (event.clientY - rect.top - panY) / zoom;\n        let clickedOnItem = false;\n        for (let i = canvasItems.length - 1; i >= 0; i--) {\n            const item = canvasItems[i];\n            // considering each character as 16px wide and 24px tall\n            if (\n                mouseX >= item.x && \n                mouseX <= item.x + (16 * item.text.length) &&\n                mouseY >= item.y - 24 && \n                mouseY <= item.y\n            ) {\n                setDragging(true);\n                setDragItemIndex(i);\n                clickedOnItem = true;\n                break;\n            }\n        }\n\n        // if user did not click on an item, start panning\n        if (!clickedOnItem) {\n            setIsPanning(true);\n            setStartPanX(event.clientX - panX);\n            setStartPanY(event.clientY - panY);\n        }\n    };\n\n    const handleMouseUp = () => {\n        setIsPanning(false);\n        setDragging(false);\n        setDragItemIndex(null);\n    };\n\n    const handleMouseMove = (event) => {\n        if (isPanning) {\n            // calculate new pan values\n            let newPanX = event.clientX - startPanX;\n            let newPanY = event.clientY - startPanY;\n\n            // define maximum and minimum allowed pan values\n            const maxPanX = 900;\n            const maxPanY = 500;\n            const minPanX = 800;\n            const minPanY = 300;\n\n            // check if new pan values exceed maximum or minimum allowed values\n            if (newPanX > maxPanX) {\n                newPanX = maxPanX;\n            } else if (newPanX < minPanX) {\n                newPanX = minPanX;\n            }\n            if (newPanY > maxPanY) {\n                newPanY = maxPanY;\n            } else if (newPanY < minPanY) {\n                newPanY = minPanY;\n            }\n\n            // update pan values\n            setPanX(newPanX);\n            setPanY(newPanY);\n        } else if (dragging && dragItemIndex !== null) {\n          // update position of dragged item\n          const rect = canvasRef.current.getBoundingClientRect();\n          const x = (event.clientX - rect.left - panX) / zoom;\n          const y = (event.clientY - rect.top - panY) / zoom;\n          setCanvasItems((prevItems) => {\n              const newItems = [...prevItems];\n              newItems[dragItemIndex] = { ...newItems[dragItemIndex], x, y };\n              return newItems;\n          });\n        }\n    };\n\n    const handleWheel = (event) => {\n      event.preventDefault();\n\n      // update zoom based on scroll direction\n      let newZoom;\n      if (event.deltaY < 0) {\n          newZoom = zoom * zoomFactor;\n      } else {\n          newZoom = zoom / zoomFactor;\n      }\n\n      // check if new zoom value is within allowed range\n      if (newZoom < minZoom) {\n          newZoom = minZoom;\n      } else if (newZoom > maxZoom) {\n          newZoom = maxZoom;\n      }\n\n      // update zoom value\n      setZoom(newZoom);\n    };\n\n    canvas.addEventListener('mousedown', handleMouseDown);\n    canvas.addEventListener('mouseup', handleMouseUp);\n    canvas.addEventListener('mouseout', handleMouseUp);\n    canvas.addEventListener('mousemove', handleMouseMove);\n    canvas.addEventListener('wheel', handleWheel);\n\n    return () => {\n        window.cancelAnimationFrame(animationFrameId);\n        canvas.removeEventListener('mousedown', handleMouseDown);\n        canvas.removeEventListener('mouseup', handleMouseUp);\n        canvas.removeEventListener('mouseout', handleMouseUp);\n        canvas.removeEventListener('mousemove', handleMouseMove);\n        canvas.removeEventListener('wheel', handleWheel);\n    };\n}, [draw, panX, panY, zoom, isPanning, startPanX, startPanY, dragging, dragItemIndex]);\n\n\n    return <canvas ref={canvasRef} onDrop={onDrop} onDragOver={onDragOver} />;\n};\n\nexport default CanvasComponent;\n","/Users/kaandai/Desktop/react-freash-canvas/src/index.js",[],[],"/Users/kaandai/Desktop/react-freash-canvas/src/reportWebVitals.js",[],[],{"ruleId":"33","severity":1,"message":"34","line":102,"column":11,"nodeType":"35","messageId":"36","endLine":102,"endColumn":22},{"ruleId":"33","severity":1,"message":"37","line":123,"column":11,"nodeType":"35","messageId":"36","endLine":123,"endColumn":20},{"ruleId":"33","severity":1,"message":"38","line":128,"column":11,"nodeType":"35","messageId":"36","endLine":128,"endColumn":22},{"ruleId":"39","severity":1,"message":"40","line":296,"column":4,"nodeType":"41","endLine":296,"endColumn":86,"suggestions":"42"},"no-unused-vars","'onMouseDown' is assigned a value but never used.","Identifier","unusedVar","'onMouseUp' is assigned a value but never used.","'onMouseMove' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'canvasItems'. Either include it or remove the dependency array.","ArrayExpression",["43"],{"desc":"44","fix":"45"},"Update the dependencies array to be: [draw, panX, panY, zoom, isPanning, startPanX, startPanY, dragging, dragItemIndex, canvasItems]",{"range":"46","text":"47"},[9766,9848],"[draw, panX, panY, zoom, isPanning, startPanX, startPanY, dragging, dragItemIndex, canvasItems]"]