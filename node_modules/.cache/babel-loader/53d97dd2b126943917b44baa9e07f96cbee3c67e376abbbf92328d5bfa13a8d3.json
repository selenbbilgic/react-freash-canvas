{"ast":null,"code":"var _jsxFileName = \"/Users/selenbilgic/Desktop/react-freash-canvas/src/CanvasComponent.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState, useCallback } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CanvasComponent = () => {\n  _s();\n  const canvasRef = useRef(null);\n  const [canvasItems, setCanvasItems] = useState([]);\n  //const [dragItem, setDragItem] = useState(null);\n  const [dragging, setDragging] = useState(false);\n  const [dragItemIndex, setDragItemIndex] = useState(null);\n\n  // Variables for panning\n  const [panX, setPanX] = useState(0);\n  const [panY, setPanY] = useState(0);\n\n  // Variables for zooming\n  const [zoom, setZoom] = useState(1);\n  const zoomFactor = 1.01;\n  const minZoom = 0.6; // minimum zoom level\n  const maxZoom = 3; // maximum zoom level\n\n  // Variables for mouse panning\n  const [isPanning, setIsPanning] = useState(false);\n  const [startPanX, setStartPanX] = useState(0);\n  const [startPanY, setStartPanY] = useState(0);\n  const drawGrid = useCallback((ctx, canvas) => {\n    ctx.beginPath();\n    ctx.strokeStyle = \"lightgray\";\n    ctx.lineWidth = 2;\n\n    // calculate the number of lines to draw based on the zoom level\n    const numLines = Math.ceil(Math.max(canvas.width, canvas.height) / (5 * zoom));\n\n    // draw vertical lines\n    for (let i = -numLines; i <= numLines; i++) {\n      const x = panX % (15 * zoom) + i * 15 * zoom;\n      ctx.moveTo(x, -canvas.height);\n      ctx.lineTo(x, canvas.height);\n    }\n\n    // draw horizontal lines\n    for (let i = -numLines; i <= numLines; i++) {\n      const y = panY % (20 * zoom) + i * 15 * zoom;\n      ctx.moveTo(-canvas.width, y);\n      ctx.lineTo(canvas.width, y);\n    }\n    ctx.stroke();\n  }, [panX, panY, zoom]);\n\n  // Draw function\n  const draw = useCallback((ctx, canvas) => {\n    // clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // save context state\n    ctx.save();\n\n    // translate and scale context\n    ctx.translate(panX, panY);\n    ctx.scale(zoom, zoom);\n\n    // draw grid\n    drawGrid(ctx, canvas);\n\n    // restore context state\n    ctx.restore();\n\n    // request next animation frame\n    requestAnimationFrame(() => draw(ctx, canvas));\n    ctx.font = \"16px Arial\";\n    ctx.fillStyle = \"black\";\n    for (const item of canvasItems) {\n      ctx.fillText(item.text, item.x, item.y);\n    }\n  }, [panX, panY, zoom, canvasItems]);\n  const onDrop = event => {\n    event.preventDefault();\n    const data = event.dataTransfer.getData(\"text/plain\");\n\n    // Calculate the position where the item was dropped and add the item to the canvas items array\n    const rect = canvasRef.current.getBoundingClientRect();\n    const x = (event.clientX - rect.left - panX) / zoom;\n    const y = (event.clientY - rect.top - panY) / zoom;\n    setCanvasItems([...canvasItems, {\n      text: data,\n      x,\n      y\n    }]);\n  };\n  const onDragOver = event => {\n    event.preventDefault(); // This is necessary to allow a drop.\n  };\n\n  const onMouseDown = useCallback(event => {\n    const rect = canvasRef.current.getBoundingClientRect();\n    const mouseX = (event.clientX - rect.left - panX) / zoom;\n    const mouseY = (event.clientY - rect.top - panY) / zoom;\n    for (let i = canvasItems.length - 1; i >= 0; i--) {\n      const item = canvasItems[i];\n      // considering each character as 16px wide and 24px tall\n      if (mouseX >= item.x && mouseX <= item.x + 16 * item.text.length && mouseY >= item.y - 24 && mouseY <= item.y) {\n        setDragging(true);\n        setDragItemIndex(i);\n        break;\n      }\n    }\n  }, [canvasItems, panX, panY, zoom]);\n  const onMouseUp = useCallback(() => {\n    setDragging(false);\n    setDragItemIndex(null);\n  }, []);\n  const onMouseMove = useCallback(event => {\n    if (isPanning) {\n      // calculate new pan values\n      let newPanX = event.clientX - startPanX;\n      let newPanY = event.clientY - startPanY;\n\n      // define maximum and minimum allowed pan values\n      const maxPanX = 900;\n      const maxPanY = 500;\n      const minPanX = 800;\n      const minPanY = 300;\n\n      // check if new pan values exceed maximum or minimum allowed values\n      if (newPanX > maxPanX) {\n        newPanX = maxPanX;\n      } else if (newPanX < minPanX) {\n        newPanX = minPanX;\n      }\n      if (newPanY > maxPanY) {\n        newPanY = maxPanY;\n      } else if (newPanY < minPanY) {\n        newPanY = minPanY;\n      }\n\n      // update pan values\n      setPanX(newPanX);\n      setPanY(newPanY);\n    }\n    if (dragging && dragItemIndex !== null) {\n      const rect = canvasRef.current.getBoundingClientRect();\n      const x = (event.clientX - rect.left - panX) / zoom;\n      const y = (event.clientY - rect.top - panY) / zoom;\n      setCanvasItems(prevItems => {\n        const newItems = [...prevItems];\n        newItems[dragItemIndex] = {\n          ...newItems[dragItemIndex],\n          x,\n          y\n        };\n        return newItems;\n      });\n    }\n  }, [dragging, dragItemIndex, isPanning, panX, panY, startPanX, startPanY, zoom]);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n    let animationFrameId;\n    const render = () => {\n      draw(ctx, canvas);\n      animationFrameId = window.requestAnimationFrame(render);\n    };\n    render();\n\n    // Add event listeners for panning and zooming\n    const handleMouseDown = event => {\n      // check if user clicked on an item\n      const rect = canvasRef.current.getBoundingClientRect();\n      const mouseX = (event.clientX - rect.left - panX) / zoom;\n      const mouseY = (event.clientY - rect.top - panY) / zoom;\n      let clickedOnItem = false;\n      for (let i = canvasItems.length - 1; i >= 0; i--) {\n        const item = canvasItems[i];\n        // considering each character as 16px wide and 24px tall\n        if (mouseX >= item.x && mouseX <= item.x + 16 * item.text.length && mouseY >= item.y - 24 && mouseY <= item.y) {\n          setDragging(true);\n          setDragItemIndex(i);\n          clickedOnItem = true;\n          break;\n        }\n      }\n\n      // if user did not click on an item, start panning\n      if (!clickedOnItem) {\n        setIsPanning(true);\n        setStartPanX(event.clientX - panX);\n        setStartPanY(event.clientY - panY);\n      }\n    };\n    const handleMouseUp = () => {\n      setIsPanning(false);\n      setDragging(false);\n      setDragItemIndex(null);\n    };\n    const handleMouseMove = event => {\n      if (isPanning) {\n        // calculate new pan values\n        let newPanX = event.clientX - startPanX;\n        let newPanY = event.clientY - startPanY;\n\n        // define maximum and minimum allowed pan values\n        const maxPanX = 900;\n        const maxPanY = 500;\n        const minPanX = 800;\n        const minPanY = 300;\n\n        // check if new pan values exceed maximum or minimum allowed values\n        if (newPanX > maxPanX) {\n          newPanX = maxPanX;\n        } else if (newPanX < minPanX) {\n          newPanX = minPanX;\n        }\n        if (newPanY > maxPanY) {\n          newPanY = maxPanY;\n        } else if (newPanY < minPanY) {\n          newPanY = minPanY;\n        }\n\n        // update pan values\n        setPanX(newPanX);\n        setPanY(newPanY);\n      } else if (dragging && dragItemIndex !== null) {\n        // update position of dragged item\n        const rect = canvasRef.current.getBoundingClientRect();\n        const x = (event.clientX - rect.left - panX) / zoom;\n        const y = (event.clientY - rect.top - panY) / zoom;\n        setCanvasItems(prevItems => {\n          const newItems = [...prevItems];\n          newItems[dragItemIndex] = {\n            ...newItems[dragItemIndex],\n            x,\n            y\n          };\n          return newItems;\n        });\n      }\n    };\n    const handleWheel = event => {\n      event.preventDefault();\n\n      // update zoom based on scroll direction\n      let newZoom;\n      if (event.deltaY < 0) {\n        newZoom = zoom * zoomFactor;\n      } else {\n        newZoom = zoom / zoomFactor;\n      }\n\n      // check if new zoom value is within allowed range\n      if (newZoom < minZoom) {\n        newZoom = minZoom;\n      } else if (newZoom > maxZoom) {\n        newZoom = maxZoom;\n      }\n\n      // update zoom value\n      setZoom(newZoom);\n    };\n    canvas.addEventListener('mousedown', handleMouseDown);\n    canvas.addEventListener('mouseup', handleMouseUp);\n    canvas.addEventListener('mouseout', handleMouseUp);\n    canvas.addEventListener('mousemove', handleMouseMove);\n    canvas.addEventListener('wheel', handleWheel);\n    return () => {\n      window.cancelAnimationFrame(animationFrameId);\n      canvas.removeEventListener('mousedown', handleMouseDown);\n      canvas.removeEventListener('mouseup', handleMouseUp);\n      canvas.removeEventListener('mouseout', handleMouseUp);\n      canvas.removeEventListener('mousemove', handleMouseMove);\n      canvas.removeEventListener('wheel', handleWheel);\n    };\n  }, [draw, panX, panY, zoom, isPanning, startPanX, startPanY, dragging, dragItemIndex]);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    onDrop: onDrop,\n    onDragOver: onDragOver\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 290,\n    columnNumber: 12\n  }, this);\n};\n_s(CanvasComponent, \"GYZITlLeFRGlSEUzulGtUDFWZiU=\");\n_c = CanvasComponent;\nexport default CanvasComponent;\nvar _c;\n$RefreshReg$(_c, \"CanvasComponent\");","map":{"version":3,"names":["React","useEffect","useRef","useState","useCallback","jsxDEV","_jsxDEV","CanvasComponent","_s","canvasRef","canvasItems","setCanvasItems","dragging","setDragging","dragItemIndex","setDragItemIndex","panX","setPanX","panY","setPanY","zoom","setZoom","zoomFactor","minZoom","maxZoom","isPanning","setIsPanning","startPanX","setStartPanX","startPanY","setStartPanY","drawGrid","ctx","canvas","beginPath","strokeStyle","lineWidth","numLines","Math","ceil","max","width","height","i","x","moveTo","lineTo","y","stroke","draw","clearRect","save","translate","scale","restore","requestAnimationFrame","font","fillStyle","item","fillText","text","onDrop","event","preventDefault","data","dataTransfer","getData","rect","current","getBoundingClientRect","clientX","left","clientY","top","onDragOver","onMouseDown","mouseX","mouseY","length","onMouseUp","onMouseMove","newPanX","newPanY","maxPanX","maxPanY","minPanX","minPanY","prevItems","newItems","getContext","window","innerWidth","innerHeight","animationFrameId","render","handleMouseDown","clickedOnItem","handleMouseUp","handleMouseMove","handleWheel","newZoom","deltaY","addEventListener","cancelAnimationFrame","removeEventListener","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/selenbilgic/Desktop/react-freash-canvas/src/CanvasComponent.js"],"sourcesContent":["import React, { useEffect, useRef, useState, useCallback } from 'react';\nconst CanvasComponent = () => {\n    \n    const canvasRef = useRef(null);\n    const [canvasItems, setCanvasItems] = useState([]);\n    //const [dragItem, setDragItem] = useState(null);\n    const [dragging, setDragging] = useState(false);\n    const [dragItemIndex, setDragItemIndex] = useState(null);\n\n\n\n    // Variables for panning\n    const [panX, setPanX] = useState(0);\n    const [panY, setPanY] = useState(0);\n\n    // Variables for zooming\n    const [zoom, setZoom] = useState(1);\n    const zoomFactor = 1.01;\n    const minZoom = 0.6; // minimum zoom level\n    const maxZoom = 3; // maximum zoom level\n\n    // Variables for mouse panning\n    const [isPanning, setIsPanning] = useState(false);\n    const [startPanX, setStartPanX] = useState(0);\n    const [startPanY, setStartPanY] = useState(0); \n\n    const drawGrid = useCallback((ctx, canvas) => {\n      ctx.beginPath();\n      ctx.strokeStyle = \"lightgray\";\n      ctx.lineWidth = 2;\n    \n      // calculate the number of lines to draw based on the zoom level\n      const numLines = Math.ceil(Math.max(canvas.width, canvas.height) / (5 * zoom));\n      \n      // draw vertical lines\n      for (let i = -numLines; i <= numLines; i++) {\n        const x = (panX % (15 * zoom)) + i * 15 * zoom;\n        ctx.moveTo(x, -canvas.height);\n        ctx.lineTo(x, canvas.height);\n      }\n      \n      // draw horizontal lines\n      for (let i = -numLines; i <= numLines; i++) {\n        const y = (panY % (20 * zoom)) + i * 15 * zoom;\n        ctx.moveTo(-canvas.width, y);\n        ctx.lineTo(canvas.width, y);\n      }\n    \n      ctx.stroke();\n  }, [panX, panY, zoom]);\n\n    // Draw function\n    const draw = useCallback((ctx, canvas) => {\n        // clear canvas\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n        // save context state\n        ctx.save();\n\n        // translate and scale context\n        ctx.translate(panX, panY);\n        ctx.scale(zoom, zoom);\n\n        // draw grid\n        drawGrid(ctx, canvas);\n\n        // restore context state\n        ctx.restore();\n\n        // request next animation frame\n        requestAnimationFrame(() => draw(ctx, canvas));\n        ctx.font = \"16px Arial\";\n        ctx.fillStyle = \"black\";\n        for (const item of canvasItems) {\n            ctx.fillText(item.text, item.x, item.y);\n        }\n    }, [panX, panY, zoom, canvasItems]);\n\n    const onDrop = (event) => {\n      event.preventDefault();\n      const data = event.dataTransfer.getData(\"text/plain\");\n      \n      // Calculate the position where the item was dropped and add the item to the canvas items array\n      const rect = canvasRef.current.getBoundingClientRect();\n      const x = (event.clientX - rect.left - panX) / zoom;\n      const y = (event.clientY - rect.top - panY) / zoom;\n      setCanvasItems([...canvasItems, { text: data, x, y }]);\n  };\n\n    const onDragOver = (event) => {\n        event.preventDefault();  // This is necessary to allow a drop.\n    };\n\n    const onMouseDown = useCallback((event) => {\n      const rect = canvasRef.current.getBoundingClientRect();\n      const mouseX = (event.clientX - rect.left - panX) / zoom;\n      const mouseY = (event.clientY - rect.top - panY) / zoom;\n\n      for (let i = canvasItems.length - 1; i >= 0; i--) {\n        const item = canvasItems[i];\n        // considering each character as 16px wide and 24px tall\n        if (\n          mouseX >= item.x && \n          mouseX <= item.x + (16 * item.text.length) &&\n          mouseY >= item.y - 24 && \n          mouseY <= item.y\n        ) {\n          setDragging(true);\n          setDragItemIndex(i);\n          break;\n        }\n      }\n    }, [canvasItems, panX, panY, zoom]);\n\n    const onMouseUp = useCallback(() => {\n      setDragging(false);\n      setDragItemIndex(null);\n    }, []);\n\n    const onMouseMove = useCallback((event) => {\n      if (isPanning) {\n          // calculate new pan values\n          let newPanX = event.clientX - startPanX;\n          let newPanY = event.clientY - startPanY;\n  \n          // define maximum and minimum allowed pan values\n          const maxPanX = 900;\n          const maxPanY = 500;\n          const minPanX = 800;\n          const minPanY = 300;\n  \n          // check if new pan values exceed maximum or minimum allowed values\n          if (newPanX > maxPanX) {\n              newPanX = maxPanX;\n          } else if (newPanX < minPanX) {\n              newPanX = minPanX;\n          }\n          if (newPanY > maxPanY) {\n              newPanY = maxPanY;\n          } else if (newPanY < minPanY) {\n              newPanY = minPanY;\n          }\n  \n          // update pan values\n          setPanX(newPanX);\n          setPanY(newPanY);\n      }\n      if (dragging && dragItemIndex !== null) {\n          const rect = canvasRef.current.getBoundingClientRect();\n          const x = (event.clientX - rect.left - panX) / zoom;\n          const y = (event.clientY - rect.top - panY) / zoom;\n          setCanvasItems(prevItems => {\n              const newItems = [...prevItems];\n              newItems[dragItemIndex] = { ...newItems[dragItemIndex], x, y };\n              return newItems;\n          });\n      }\n  }, [dragging, dragItemIndex, isPanning, panX, panY, startPanX, startPanY, zoom]);\n  \n    \n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n    let animationFrameId;\n\n    const render = () => {\n        draw(ctx, canvas);\n        animationFrameId = window.requestAnimationFrame(render);\n    };\n    render();\n\n    // Add event listeners for panning and zooming\n    const handleMouseDown = (event) => {\n        // check if user clicked on an item\n        const rect = canvasRef.current.getBoundingClientRect();\n        const mouseX = (event.clientX - rect.left - panX) / zoom;\n        const mouseY = (event.clientY - rect.top - panY) / zoom;\n        let clickedOnItem = false;\n        for (let i = canvasItems.length - 1; i >= 0; i--) {\n            const item = canvasItems[i];\n            // considering each character as 16px wide and 24px tall\n            if (\n                mouseX >= item.x && \n                mouseX <= item.x + (16 * item.text.length) &&\n                mouseY >= item.y - 24 && \n                mouseY <= item.y\n            ) {\n                setDragging(true);\n                setDragItemIndex(i);\n                clickedOnItem = true;\n                break;\n            }\n        }\n\n        // if user did not click on an item, start panning\n        if (!clickedOnItem) {\n            setIsPanning(true);\n            setStartPanX(event.clientX - panX);\n            setStartPanY(event.clientY - panY);\n        }\n    };\n\n    const handleMouseUp = () => {\n        setIsPanning(false);\n        setDragging(false);\n        setDragItemIndex(null);\n    };\n\n    const handleMouseMove = (event) => {\n        if (isPanning) {\n            // calculate new pan values\n            let newPanX = event.clientX - startPanX;\n            let newPanY = event.clientY - startPanY;\n\n            // define maximum and minimum allowed pan values\n            const maxPanX = 900;\n            const maxPanY = 500;\n            const minPanX = 800;\n            const minPanY = 300;\n\n            // check if new pan values exceed maximum or minimum allowed values\n            if (newPanX > maxPanX) {\n                newPanX = maxPanX;\n            } else if (newPanX < minPanX) {\n                newPanX = minPanX;\n            }\n            if (newPanY > maxPanY) {\n                newPanY = maxPanY;\n            } else if (newPanY < minPanY) {\n                newPanY = minPanY;\n            }\n\n            // update pan values\n            setPanX(newPanX);\n            setPanY(newPanY);\n        } else if (dragging && dragItemIndex !== null) {\n          // update position of dragged item\n          const rect = canvasRef.current.getBoundingClientRect();\n          const x = (event.clientX - rect.left - panX) / zoom;\n          const y = (event.clientY - rect.top - panY) / zoom;\n          setCanvasItems((prevItems) => {\n              const newItems = [...prevItems];\n              newItems[dragItemIndex] = { ...newItems[dragItemIndex], x, y };\n              return newItems;\n          });\n        }\n    };\n\n    const handleWheel = (event) => {\n      event.preventDefault();\n\n      // update zoom based on scroll direction\n      let newZoom;\n      if (event.deltaY < 0) {\n          newZoom = zoom * zoomFactor;\n      } else {\n          newZoom = zoom / zoomFactor;\n      }\n\n      // check if new zoom value is within allowed range\n      if (newZoom < minZoom) {\n          newZoom = minZoom;\n      } else if (newZoom > maxZoom) {\n          newZoom = maxZoom;\n      }\n\n      // update zoom value\n      setZoom(newZoom);\n    };\n\n    canvas.addEventListener('mousedown', handleMouseDown);\n    canvas.addEventListener('mouseup', handleMouseUp);\n    canvas.addEventListener('mouseout', handleMouseUp);\n    canvas.addEventListener('mousemove', handleMouseMove);\n    canvas.addEventListener('wheel', handleWheel);\n\n    return () => {\n        window.cancelAnimationFrame(animationFrameId);\n        canvas.removeEventListener('mousedown', handleMouseDown);\n        canvas.removeEventListener('mouseup', handleMouseUp);\n        canvas.removeEventListener('mouseout', handleMouseUp);\n        canvas.removeEventListener('mousemove', handleMouseMove);\n        canvas.removeEventListener('wheel', handleWheel);\n    };\n}, [draw, panX, panY, zoom, isPanning, startPanX, startPanY, dragging, dragItemIndex]);\n\n\n    return <canvas ref={canvasRef} onDrop={onDrop} onDragOver={onDragOver} />;\n};\n\nexport default CanvasComponent;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}